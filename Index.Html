<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px; z-index: 2;
            width: 200px; height: 150px; border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; overflow: hidden;
            transform: scaleX(-1); /* Mirror the webcam */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 3; color: white; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        p { font-size: 0.9rem; color: #ccc; }
        .highlight { color: #00ffff; font-weight: bold; }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- Import MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Particle Morph</h1>
        <p>1. Allow Camera Access</p>
        <p>2. <span class="highlight">Move Hand Left/Right</span> to Rotate & Change Color</p>
        <p>3. <span class="highlight">Pinch (Thumb+Index)</span> to Collapse/Expand</p>
        <p>Current Shape: <span id="shape-name">Loading...</span></p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const PARTICLE_COUNT = 25000;
        const PARTICLE_SIZE = 0.15;
        const MORPH_SPEED = 0.05; // How fast particles move to target
        
        // --- State ---
        let scene, camera, renderer, particles;
        let positions, targetPositions;
        let clock = new THREE.Clock();
        
        // Interaction State
        let handInteraction = {
            active: false,
            pinchDistance: 1.0, // 0 = pinched, 1 = open
            handX: 0.5, // 0 to 1
            handY: 0.5
        };

        const shapeNameEl = document.getElementById('shape-name');

        // --- Init Three.js ---
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            createParticles();
            
            // Handle Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        // --- Particle System ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            // Initialize random positions
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                
                colors[i * 3] = 1;
                colors[i * 3 + 1] = 1;
                colors[i * 3 + 2] = 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Create a soft glowing texture for particles
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: sprite,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Start with Sphere
            setTargetShape('sphere');
        }

        // --- Shape Formulas ---
        
        function setTargetShape(type) {
            shapeNameEl.innerText = type.toUpperCase();
            const scale = 12; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                const i3 = i * 3;

                if (type === 'sphere') {
                    const r = scale * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (type === 'heart') {
                    // Parametric Heart
                    let t = Math.random() * Math.PI * 2;
                    // Spread particles inside the volume
                    let r = scale * Math.sqrt(Math.random()) * 0.05; 
                    
                    // Basic heart curve
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    x = hx * r;
                    y = hy * r;
                    z = (Math.random() - 0.5) * scale * 0.5; // Thickness
                } 
                else if (type === 'saturn') {
                    // 70% Planet, 30% Rings
                    if (Math.random() > 0.3) {
                        // Planet
                        const r = scale * 0.6 * Math.cbrt(Math.random());
                        const theta = Math.random() * 2 * Math.PI;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        // Rings (Annulus)
                        const angle = Math.random() * Math.PI * 2;
                        const dist = (scale * 0.8) + Math.random() * (scale * 0.6);
                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        y = (Math.random() - 0.5) * 0.5; // Thin ring
                    }
                }
                else if (type === 'flower') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const r = scale * Math.sin(3*u) * Math.sin(v); // 3 petals
                    x = r * Math.sin(u) * Math.cos(v);
                    y = r * Math.sin(u) * Math.sin(v);
                    z = r * Math.cos(u);
                }
                else if (type === 'helix') {
                    const t = i / PARTICLE_COUNT * 20 * Math.PI;
                    x = Math.cos(t) * scale * 0.5;
                    z = Math.sin(t) * scale * 0.5;
                    y = (i / PARTICLE_COUNT - 0.5) * scale * 2;
                    // Add some noise
                    x += (Math.random()-0.5);
                    z += (Math.random()-0.5);
                }

                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            
            // 1. Gesture Control: Rotation
            // Map hand X (0-1) to rotation speed and direction
            let targetRotationY = time * 0.1;
            let targetRotationX = 0;

            if (handInteraction.active) {
                // Hand X controls Y rotation speed/direction
                targetRotationY = (handInteraction.handX - 0.5) * 5; 
                targetRotationX = (handInteraction.handY - 0.5) * 5;
            }
            
            particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.05;
            particles.rotation.x += (targetRotationX - particles.rotation.x) * 0.05;

            // 2. Gesture Control: Color
            // Shift Hue based on Hand X
            let hue = (time * 0.1) % 1;
            if(handInteraction.active) {
                hue = handInteraction.handX;
            }
            const colorObj = new THREE.Color().setHSL(hue, 1.0, 0.6);
            particles.material.color.lerp(colorObj, 0.1);

            // 3. Gesture Control: Expansion (Pinch)
            // If pinchDistance is small (pinched), expandFactor goes high (explode)
            // If pinchDistance is large (open hand), particles condense to shape
            // Let's invert: Open hand = Shape. Pinch = Collapse/Tighten. 
            // Actually, let's do: Pinch = Condense to 0, Open = Normal Size.
            // Let's do: Hand Close = Explode out, Hand Open = Normal.
            
            // Refined Logic: 
            // pinchDistance: 0 (fingers touching) -> 1 (open)
            // We want particles to fly out when we pinch? Or when we open?
            // Let's make Pinch = Contract to center (0.1 scale), Open = Normal (1.0 scale)
            let expansion = 1.0;
            if (handInteraction.active) {
                // Map 0..1 to 0.1..2.0
                expansion = 0.2 + (handInteraction.pinchDistance * 1.5); 
            }

            // 4. Update Particles
            const positionsAttribute = particles.geometry.attributes.position;
            const currentPos = positionsAttribute.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // Get target
                const tx = targetPositions[i3] * expansion;
                const ty = targetPositions[i3 + 1] * expansion;
                const tz = targetPositions[i3 + 2] * expansion;

                // Lerp current to target
                currentPos[i3] += (tx - currentPos[i3]) * MORPH_SPEED;
                currentPos[i3 + 1] += (ty - currentPos[i3 + 1]) * MORPH_SPEED;
                currentPos[i3 + 2] += (tz - currentPos[i3 + 2]) * MORPH_SPEED;
                
                // Add subtle noise movement
                currentPos[i3] += Math.sin(time + i) * 0.02;
                currentPos[i3+1] += Math.cos(time + i * 0.5) * 0.02;
            }

            positionsAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- Shape Cycling ---
        const shapes = ['sphere', 'heart', 'saturn', 'flower', 'helix'];
        let currentShapeIndex = 0;
        
        setInterval(() => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            setTargetShape(shapes[currentShapeIndex]);
        }, 5000); // Change shape every 5 seconds

        // --- MediaPipe Setup ---
        const videoElement = document.getElementById('input_video');
        
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handInteraction.active = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. Get Thumb (4) and Index (8) tips
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // 2. Calculate Distance (Euclidean, ignore Z for simplicity in interaction)
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Normalize distance (approximate max pinch distance is around 0.2 in normalized coord)
                // We clamp and map it to 0..1 range
                let pinchNorm = Math.min(Math.max(distance / 0.15, 0), 1);
                handInteraction.pinchDistance = pinchNorm;

                // 3. Get Hand Position (Index tip)
                // MediaPipe gives x=0 (left) to x=1 (right). 
                // We mirrored the video via CSS, but landmarks are original coordinates? 
                // Actually MediaPipe x increases left-to-right.
                handInteraction.handX = 1.0 - indexTip.x; // Flip because of mirrored feel
                handInteraction.handY = indexTip.y;

            } else {
                handInteraction.active = false;
                // Slowly return to default state
                handInteraction.pinchDistance += (1.0 - handInteraction.pinchDistance) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // Start everything
        initScene();
        cameraUtils.start();

    </script>
</body>
</html>